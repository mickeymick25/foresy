#!/usr/bin/env ruby
# frozen_string_literal: true

# check_concerns_architecture
#
# Script de vÃ©rification de l'architecture des concerns
# Ã€ exÃ©cuter en CI pour garantir les invariants architecturaux
#
# RÃ¨gles vÃ©rifiÃ©es:
# 1. Un fichier = Un module (Zeitwerk compliance)
# 2. Pas de fichiers *_new.rb ou *_old.rb
# 3. Pas de dossiers vides dans les concerns
# 4. Tous les concerns spÃ©cialisÃ©s incluent leur Common correspondant
#
# Usage:
#   bin/check_concerns_architecture
#   bin/check_concerns_architecture --verbose
#
# Exit codes:
#   0 - Toutes les vÃ©rifications passent
#   1 - Au moins une vÃ©rification Ã©choue

require 'pathname'

class ConcernsArchitectureChecker
  CONCERNS_PATHS = [
    'app/controllers/concerns',
    'app/concerns'
  ].freeze

  FORBIDDEN_SUFFIXES = %w[_new _old _backup _tmp _temp].freeze

  COMMON_CONCERNS = %w[
    ErrorHandler
    ParameterExtractor
    RateLimitable
    ResponseFormatter
  ].freeze

  def initialize(verbose: false)
    @verbose = verbose
    @errors = []
    @warnings = []
    @root = Pathname.new(File.expand_path('../..', __FILE__))
  end

  def run
    puts "ðŸ” VÃ©rification de l'architecture des concerns...\n\n"

    check_single_module_per_file
    check_forbidden_suffixes
    check_empty_directories
    check_common_inheritance
    check_zeitwerk_compliance

    print_results
    @errors.empty? ? 0 : 1
  end

  private

  # RÃ¨gle 1: Un fichier = Un module
  def check_single_module_per_file
    log_check "VÃ©rification: 1 fichier = 1 module (Zeitwerk)"

    concern_files.each do |file|
      content = File.read(file)
      module_count = content.scan(/^\s*module\s+\w+/).count

      # On compte les modules imbriquÃ©s comme normaux (Api::V1::Cras = 3 modules imbriquÃ©s)
      # Mais on dÃ©tecte les modules sÃ©parÃ©s (plusieurs dÃ©finitions de mÃªme niveau)
      root_modules = content.scan(/^module\s+\w+/).count

      if root_modules > 1
        @errors << {
          file: relative_path(file),
          message: "Fichier contient #{root_modules} modules racine (attendu: 1)",
          severity: :critical
        }
      else
        log_ok relative_path(file) if @verbose
      end
    end
  end

  # RÃ¨gle 2: Pas de fichiers avec suffixes interdits
  def check_forbidden_suffixes
    log_check "VÃ©rification: Pas de fichiers *_new.rb, *_old.rb, etc."

    concern_files.each do |file|
      basename = File.basename(file, '.rb')
      FORBIDDEN_SUFFIXES.each do |suffix|
        if basename.end_with?(suffix)
          @errors << {
            file: relative_path(file),
            message: "Fichier avec suffixe interdit '#{suffix}' dÃ©tectÃ©",
            severity: :critical
          }
        end
      end
    end
  end

  # RÃ¨gle 3: Pas de dossiers vides
  def check_empty_directories
    log_check "VÃ©rification: Pas de dossiers vides"

    CONCERNS_PATHS.each do |path|
      full_path = @root.join(path)
      next unless full_path.exist?

      Dir.glob(full_path.join('**/*')).select { |d| File.directory?(d) }.each do |dir|
        if Dir.empty?(dir)
          @warnings << {
            file: relative_path(dir),
            message: "Dossier vide dÃ©tectÃ©",
            severity: :warning
          }
        end
      end
    end
  end

  # RÃ¨gle 4: Les concerns spÃ©cialisÃ©s incluent Common
  def check_common_inheritance
    log_check "VÃ©rification: HÃ©ritage Common obligatoire"

    specialized_dirs = %w[cras cra_entries missions]

    specialized_dirs.each do |dir|
      COMMON_CONCERNS.each do |concern|
        file_name = concern.gsub(/([A-Z])/, '_\1').downcase.sub(/^_/, '') + '.rb'
        specialized_file = @root.join("app/controllers/concerns/api/v1/#{dir}/#{file_name}")

        next unless specialized_file.exist?

        content = File.read(specialized_file)
        common_include = "include Api::V1::Common::#{concern}"

        unless content.include?(common_include)
          @errors << {
            file: relative_path(specialized_file),
            message: "Doit inclure '#{common_include}'",
            severity: :major
          }
        else
          log_ok "#{dir}/#{file_name} inclut Common::#{concern}" if @verbose
        end
      end
    end
  end

  # VÃ©rification Zeitwerk
  def check_zeitwerk_compliance
    log_check "VÃ©rification: Zeitwerk compliance"

    # VÃ©rifier que les noms de fichiers correspondent aux constantes
    concern_files.each do |file|
      content = File.read(file)
      basename = File.basename(file, '.rb')

      # Extraire le dernier module imbriquÃ© (le module rÃ©el dÃ©fini dans le fichier)
      # Pattern: module Api::V1::Cras::ErrorHandler â†’ on veut ErrorHandler
      modules = content.scan(/module\s+(\w+)/).flatten
      next if modules.empty?

      # Le dernier module dans la hiÃ©rarchie est celui qui doit correspondre au nom du fichier
      last_module = modules.last
      expected_filename = last_module.gsub(/([A-Z])/, '_\1').downcase.sub(/^_/, '')

      if basename != expected_filename
        @warnings << {
          file: relative_path(file),
          message: "Nom de fichier '#{basename}' ne correspond pas Ã  la constante '#{last_module}' (attendu: #{expected_filename}.rb)",
          severity: :warning
        }
      else
        log_ok "#{relative_path(file)} â†’ #{last_module}" if @verbose
      end
    end
  end

  def concern_files
    @concern_files ||= CONCERNS_PATHS.flat_map do |path|
      full_path = @root.join(path)
      next [] unless full_path.exist?

      Dir.glob(full_path.join('**/*.rb'))
    end.compact
  end

  def relative_path(path)
    Pathname.new(path).relative_path_from(@root).to_s
  end

  def log_check(message)
    puts "ðŸ“‹ #{message}"
  end

  def log_ok(message)
    puts "   âœ… #{message}"
  end

  def print_results
    puts "\n" + "=" * 60

    if @errors.empty? && @warnings.empty?
      puts "âœ… Toutes les vÃ©rifications passent!"
      puts "   Architecture des concerns conforme aux standards FC06/FC07"
    else
      if @errors.any?
        puts "\nðŸ”´ ERREURS (#{@errors.count}):\n"
        @errors.each do |error|
          puts "   âŒ [#{error[:severity].upcase}] #{error[:file]}"
          puts "      #{error[:message]}"
        end
      end

      if @warnings.any?
        puts "\nðŸŸ¡ AVERTISSEMENTS (#{@warnings.count}):\n"
        @warnings.each do |warning|
          puts "   âš ï¸  [#{warning[:severity].upcase}] #{warning[:file]}"
          puts "      #{warning[:message]}"
        end
      end
    end

    puts "=" * 60
    puts "\nðŸ“Š RÃ©sumÃ©:"
    puts "   Fichiers analysÃ©s: #{concern_files.count}"
    puts "   Erreurs: #{@errors.count}"
    puts "   Avertissements: #{@warnings.count}"
    puts "   Statut: #{@errors.empty? ? 'âœ… PASS' : 'âŒ FAIL'}"
  end
end

# ExÃ©cution
verbose = ARGV.include?('--verbose') || ARGV.include?('-v')
checker = ConcernsArchitectureChecker.new(verbose: verbose)
exit checker.run
